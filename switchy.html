<body>
<div class="header">Switchy
<div class="subheader">Click to switch the colors of a group of cells. Rows and columns that are all the same color are eliminated. Eliminate them all to win.</div>
</div>
<table id="grid" class="grid" onmouseout="mouseout()"></table>
</body>

<style type="text/css">
.header {
    font-family: Arial;
    font-size: 60;
    text-align: center;
}
.subheader {
    font-size: 18;
    margin: 0 auto;
    margin-top: 20px;
    width: 6in;
}
.grid {
    margin: 0 auto;
    margin-top: 100px;
    padding: 20px;
    background-color: #0000FF;
}
.white { background-color: #ffffff; }
.black { background-color: #000000; }
.grey { background-color: #aaaaaa; }
.darkgrey { background-color: #555555; }
.red { background-color: #FF0000; }
</style> 

<script>
// Basic javascript stuff that I shouldn't have to write
function *range(N) {
    for (var i = 0; i < N; i++)
        yield i;
}

function *enumerate(iter) {
    for (var i = 0; i < iter.length; i++)
        yield [i, iter[i]];
}

Array.prototype.contains = function(item) {
    for (var i of this)
        // Oh javascript, you're just so awful
        if (item.toString() === i.toString())
            return true;
    return false;
}

// Game constants
N = 10
//squares = [[-1, 0], [0, -1], [0, 0], [0, 1], [1, 0]]
squares = [[x, y] for (x of range(3)) for (y of range(3))]
margin = [[minmax.apply(null, [sq[i] for (sq of squares)]) for (minmax of [Math.min, Math.max])]
    for (i of range(2))]

function reset_grid() {
    collapse();
    grid_cells = []
    grid_div = document.getElementById("grid");
    remove_children(grid_div);
    for (var r = 0; r < grid.length; r++) {
        var row = [];
        var row_div = document.createElement("tr");
        _r = Math.max(-margin[0][0], Math.min(r, grid.length - margin[0][1] - 1));
        for (var c = 0; c < grid[0].length; c++) {
            var cell = document.createElement("td");
            _c = Math.max(-margin[1][0], Math.min(c, grid[0].length - margin[1][1] - 1));
            cell.setAttribute("onmouseover", "mouseover(" + _r + ", " + _c + ")");
            cell.setAttribute("onmouseup", "mouseup(" + _r + ", " + _c + ")");
            cell.setAttribute("class", get_cell_class(grid, r, c));
            cell.setAttribute("height", 40);
            cell.setAttribute("width", 40);
            row_div.appendChild(cell);
            row.push(cell);
        }
        grid_div.appendChild(row_div);
        grid_cells.push(row);
    }
}

function remove_children(node) {
    while (node.hasChildNodes())
        node.removeChild(node.lastChild);
}
[mouse_x, mouse_y] = [null, null];

function mouseover(x, y) {
    [mouse_x, mouse_y] = [x, y];
    reset_grid();
}

function mouseup(x, y) {
    flip_switches(x, y);
    reset_grid();
}

function mouseout() {
    [mouse_x, mouse_y] = [null, null];
    reset_grid();
}

function get_cell_class(grid, x, y) {
    if (removing_rows.contains(x) || removing_cols.contains(y))
        return "red";
    if (mouse_x !== null && mouse_y !== null &&
            squares.contains([x - mouse_x, y - mouse_y]))
        return ["grey", "darkgrey"][grid[x][y]];
    return ["white", "black"][grid[x][y]];
}

function generate() {
    return [[Math.random() * 2 | 0 for (i of range(N))] for (i of range(N))];
}

function flip_switches(x, y) {
    grid = [[item ^ squares.contains([r - x, c - y]) for ([c, item] of enumerate(row))]
        for ([r, row] of enumerate(grid))];
}

function len(grid) {
    return grid.length;
}

function len_cols(grid) {
    return grid.length && grid[0].length;
}

function extract_row(grid, r) {
    return grid[r]
}

function extract_col(grid, c) {
    return [row[c] for (row of grid)]
}

function remove_rows(grid, rows) {
    return [row for ([r, row] of enumerate(grid)) if (!rows.contains(r))]
}

function remove_cols(grid, cols) {
    return [[col for ([c, col] of enumerate(row)) if (!cols.contains(c))] for (row of grid)]
}

function n_uniques(list) {
    var uniques = [];
    for (i of list)
        if (!uniques.contains(i))
            uniques.push(i);
    return uniques.length;
}

removing_rows = [];
removing_cols = [];
state = 0
function collapse() {
    if (state !== 0)
        return;
    state = 1;
    for ([length, extract, to_remove] of [[len, extract_row, removing_rows],
        [len_cols, extract_col, removing_cols]])
        for (var i of range(length(grid)))
            if (n_uniques(extract(grid, i)) <= 1)
                to_remove.push(i);

    if (grid.length && grid[0].length)
        setTimeout(clearout, 1000);
}

function clearout() {
    if (state !== 1)
        return;
    state = 2;
    for ([remove, to_remove] of [[remove_rows, removing_rows],
            [remove_cols, removing_cols]]) {
        grid = remove(grid, to_remove);
        while (to_remove.length)
            to_remove.pop();
    }
    state = 0;
    reset_grid();
}

grid = generate();
reset_grid();
</script>
